### Объяснение кода

```javascript
export const withLayout = <T extends Record<string, unknown>>(Component: FunctionComponent<T>) => {
  return function withLayoutComponent(props: T) {
    return (
      <Layout>
        <Component {...props} />
      </Layout>
    );
  };
};
```

#### 1. Что такое `T`?

- **`T`** — это обобщенный тип (generic type) в TypeScript. Он позволяет вам создавать компоненты или функции, которые могут работать с различными типами данных. В данном случае `T` будет представлять тип свойств, которые принимает компонент, переданный в `withLayout`.

#### 2. Что такое `Record<string, unknown>`?

- **`Record<K, V>`** — это встроенный утилитный тип в TypeScript, который позволяет создавать объектный тип с заданными ключами и значениями.
- В данном случае:
  - **`K`** — это тип ключей. В данном случае это `string`, что означает, что ключи будут строками.
  - **`V`** — это тип значений. Здесь используется `unknown`, что означает, что значения могут быть любого типа, но вы не знаете их заранее.
  
Таким образом, `Record<string, unknown>` создает объектный тип, где ключи — это строки, а значения могут быть любого типа. Это полезно для описания свойств компонента, когда вы не хотите ограничивать их конкретными типами.

#### 3. Определение функции высшего порядка (HOC)

```javascript
export const withLayout = <T extends Record<string, unknown>>(Component: FunctionComponent<T>) => {
```

- Здесь мы объявляем функцию `withLayout`, которая принимает один параметр `Component`. Этот параметр должен быть функциональным компонентом (`FunctionComponent<T>`), который принимает свойства типа `T`.
- Таким образом, любой компонент, передаваемый в `withLayout`, может иметь любые свойства (в соответствии с определением `Record<string, unknown>`).

#### 4. Возвращаемая функция

```javascript
return function withLayoutComponent(props: T) {
```

- Функция `withLayout` возвращает новую функцию (которая называется `withLayoutComponent`). Эта функция принимает параметры `props`, которые имеют тот же тип `T`, что и переданный компонент.
- Это позволяет передавать любые свойства от родительского компонента к обернутому компоненту.

#### 5. JSX-разметка

```javascript
return (
  <Layout>
    <Component {...props} />
  </Layout>
);
```

- Внутри функции `withLayoutComponent` мы возвращаем JSX-разметку:
  - Мы оборачиваем переданный компонент (`<Component {...props} />`) в компонент `Layout`.
  - Используя `{...props}`, мы передаем все свойства, которые были переданы в `withLayoutComponent`, непосредственно в обернутый компонент. Это позволяет сохранить все свойства и функциональность оригинального компонента.

### Пример использования

Чтобы лучше понять, как это работает на практике, давайте рассмотрим пример:

```javascript
import { withLayout } from './withLayout';

const MyPage = (props) => {
    return <div>Содержимое страницы {props.title}</div>;
};

// Оборачиваем MyPage в HOC withLayout
export default withLayout(MyPage);
```

- В этом примере компонент `MyPage` получает пропс `title`. Когда вы используете HOC `withLayout`, он автоматически оборачивает ваш компонент в макет (layout), сохраняя при этом все переданные пропсы.

### Заключение

Использование обобщенных типов и утилитных типов в TypeScript позволяет создавать более гибкие и переиспользуемые компоненты. Функции высшего порядка (HOC), такие как `withLayout`, позволяют добавлять общую функциональность к различным компонентам без необходимости дублирования кода.

Если у вас есть дополнительные вопросы или нужно объяснить что-то еще более подробно, дайте знать!